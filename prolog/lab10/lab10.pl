seg(1, point(1, 11), point(14, 11)).
seg(2, point(2, 4), point(13, 4)).
seg(3, point(2, 2), point(9, 2)).
seg(4, point(3, 1), point(3, 10)).
seg(5, point(7, 10), point(13, 10)).
seg(6, point(8, 0), point(8, 13)).
seg(7, point(10, 3), point(10, 12)).
seg(8, point(11, 3), point(11, 13)).
seg(9, point(12, 2), point(12, 12)).

/*
1. Напишите правило, определяющее номер горизонтального отрезка. Голова правила представлена термом horiz/1.
*/
horiz(N) :- seg(N, point(_, Y), point(_, Y)).

/*
1. Напишите  правило, определяющее номер вертикального отрезка. Голова правила представлена термом vertical/1.
*/
vertical(N) :- seg(N, point(X, _), point(X, _)).

/*
2. Введите в базу данных правило, определяющее пересекающиеся отрезки.
Голова правила представлена структурой cross/5, два аргумента которой N и M - номера пересекающихся отрезков,
третий - point(X,Y), описывает точку пересечения, а четвертый и пятый - длины пересекающихся отрезков.
(Если необходимо, для нахождения квадратного корня воспользуйтесь правилом sqrt(N,X), где N - число, X - квадратный корень от числа N.)
http://algolist.ru/maths/geom/intersect/lineline2d.php
*/
cross(N, M, point(X, Y), NL, ML):-
    vertical(N), horiz(M),  /* N - вертикальный отрезок, M - горизонтальный отрезок  */
    seg(N, point(X3, Y2), point(X3, Y3)), /* x3, y2 - точки начала вертикального отрезка ; x3, y3 - точки конца вертикального отрезка */
    seg(M, point(X1, Y1), point(X2, Y1)), /* x1, y1 - точки начала горизонтального отрезка ; x2, y1 - точки конца горизонтального отрезка */
    X1 < X3, X2 > X3, Y2 < Y1, Y3 > Y1,  /* условие пересечения отрезков:  */
    X is X3, Y is Y1,
    NL is Y3 - Y2,
    ML is X2 - X1.

/*
3. Добавьте в базу данных правило определения периметра и площади прямоугольников, образуемых пересекающимися отрезками.
Голова правила представлена структурой per_sq/6, четыре  аргумента которой - номера отрезков, образующих прямоугольник.
Пятый аргумент - P, периметр прямоугольника. Шестой аргумент - S, площадь периметра.
*/
perimetr(A, B, C, D, P, S):-
    cross(A, B, point(X1, _), _, _),
    cross(C, B, point(X2, Y2), _, _),
    cross(C, D, point(_, Y3), _, _),
    cross(A, D, point(_, _), _, _), /* можно удалить, но дает гарантию что все отрезки точно пересекаются */
    A \= C, B\= D,
    P is abs(X2 - X1) * 2 + abs(Y2 - Y3) * 2,
    S is abs(X2 - X1) * abs(Y2 - Y3).