#LW12. Списки. Рекурсия.

###1. Укажите, красным или зеленым является отсечение в процедуре: #1

```prolog
member(X,[X|_]):-!.
member(X,[_|L]):-member(X,L).
```
Если отсечение красное, приведите пример цели, которая дает разные решения при наличии отсечения в процедуре и его изъятии.
Приведите эти решения. (ответ пишем в комментариях)

###2. Написать отношение fib(N,F), которое находит по аргументу N (номер числа в последовательности) число Фибоначчи F. #1

Числа Фибоначчи: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377

Формула для нахождения числа Фибоначчи:

F(1)=1; F(2)=1; F(3)=2; F(n+1)=F(n)+F(n-1).

Отношение должно корректно обрабатывать свои аргументы!!!

Должно давать только одно решение!!!

Например,
```prolog
fib(0,N).
/* дает error */
fib(-1,N).
/* дает error */
fib(2,N).
/* дает N=1 */
fib(7,N).
/* дает N=13 */
```

###3.1. Отсортируйте массив методом Шелла. Сортировка Шелла алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга. Последовательность длин промежутков: #3

d(1) = N / 2, d(i) = d(i-1) / 2, d(k) = 1, где N - длина массива.

Должно давать только одно решение!!!

###3.2. Дополните программу предикатами ввода-вывода таким образом, чтобы мог быть реализован следующий диалог: #1

```prolog
?-sort_3.
list? [3,4,2,1].
answer: [1,2,3,4].
```
Что будет ответом на вопрос:

```prolog
?-place(x,L,[a,x,c]).
```

###4. Для каждого из перечисленных методов сортировки выполните следующее: Дополните программы сортировки предикатами ввода-вывода таким образом, чтобы мог быть реализован следующий диалог:

```prolog
?-sort_4.
list? [3,4,2,1].
answer: [1,2,3,4].
```

###4.1. Метод наивной сортировки (назвать правило sort_4_1). #0.5

###4.2. Метод пузырька (назвать правило sort_4_2). #0.5

###4.3. Метод вставки (назвать правило sort_4_3). #0.5

###4.4. Быстрая сортировка quick (назвать правило sort_4_4). #0.5

###5. Построить бесповторный упорядоченный список L3, состоящий из всех элементов, содержащихся как в списке L1, так и в списке L2. #3

Должно давать только одно решение!!!

```prolog
?-common([11,1,8,8,4],[6,3,2,8,6],L3).
/* дает L3=[1,2,3,4,6,8,11] */
```

###6. Определить самый распространенный элемент X в списке L. Если в списке несколько самых распространенных элементов, то ответ надо сделать в виде списка из самых распространенных элементов. #3

Должно давать только одно решение!!!

```prolog
?-most_oft([a,f,8,3,a,f,a,d,g],X).
/* дает X=a */
?-most_oft([a,f,8,3,a,f,f,d,g],X).
/* дает X=f */
?-most_oft([a,f,8,3,a,a,f,f,d,g],X).
/* дает X=[a,f] */
```
